<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>The eBPF Runtime in the Linux Kernel | wesley's Blog</title><meta name="author" content="wesley tian"><meta name="copyright" content="wesley tian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux内核中的eBPF运行时环境  翻译文献The eBPF Runtime in the Linux Kernel  摘要扩展伯克利数据包过滤器（eBPF，Extended Berkeley Packet Filter）是一种运行时环境，它允许用户将程序加载到操作系统（如Linux或Windows)的内核中，并在指定的内核钩子处安全高效地执行这些程序。每个程序都要经过一个验证器（校验器），验">
<meta property="og:type" content="article">
<meta property="og:title" content="The eBPF Runtime in the Linux Kernel">
<meta property="og:url" content="http://jiuzhao14.github.io/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/index.html">
<meta property="og:site_name" content="wesley&#39;s Blog">
<meta property="og:description" content="Linux内核中的eBPF运行时环境  翻译文献The eBPF Runtime in the Linux Kernel  摘要扩展伯克利数据包过滤器（eBPF，Extended Berkeley Packet Filter）是一种运行时环境，它允许用户将程序加载到操作系统（如Linux或Windows)的内核中，并在指定的内核钩子处安全高效地执行这些程序。每个程序都要经过一个验证器（校验器），验">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jiuzhao14.github.io/img/avatar.png">
<meta property="article:published_time" content="2025-11-02T15:49:03.000Z">
<meta property="article:modified_time" content="2025-11-02T15:56:08.516Z">
<meta property="article:author" content="wesley tian">
<meta property="article:tag" content="eBPF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jiuzhao14.github.io/img/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "The eBPF Runtime in the Linux Kernel",
  "url": "http://jiuzhao14.github.io/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/",
  "image": "http://jiuzhao14.github.io/img/avatar.png",
  "datePublished": "2025-11-02T15:49:03.000Z",
  "dateModified": "2025-11-02T15:56:08.516Z",
  "author": [
    {
      "@type": "Person",
      "name": "wesley tian",
      "url": "http://jiuzhao14.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jiuzhao14.github.io/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'The eBPF Runtime in the Linux Kernel',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/purple-green.css"><meta name="generator" content="Hexo 8.1.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="wesley's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 电影</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">wesley's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">The eBPF Runtime in the Linux Kernel</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 电影</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">The eBPF Runtime in the Linux Kernel</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-02T15:49:03.000Z" title="发表于 2025-11-02 23:49:03">2025-11-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-02T15:56:08.516Z" title="更新于 2025-11-02 23:56:08">2025-11-02</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><strong>Linux内核中的eBPF运行时环境</strong></p>
<blockquote>
<p>翻译文献The eBPF Runtime in the Linux Kernel</p>
</blockquote>
<p><strong>摘要</strong><br>扩展伯克利数据包过滤器（eBPF，Extended Berkeley Packet Filter）是一种运行时环境，它允许用户将程序加载到操作系统（如Linux或Windows)的内核中，并在指定的内核钩子处安全高效地执行这些程序。每个程序都要经过一个验证器（校验器），验证器会推断出其执行的安全保证。在内核中托管一个安全的虚拟机允许时环境，使其能够动态编程。与绕过内核或完全替代内核的流行方法不同，eBPF为用户提供了灵活性，使其能够即时修改内核，快速实验和迭代，并部署解决方法以满足特定工作负载的需求，同时与内核协同工作。</p>
<p>在本文中，我们首次全面描述了Linux内核中eBPF运行时的设计与实现。我们认为，如今的eBPF为内核提供了一个成熟且安全的编程环境。自其诞生以来，它已被广泛采用，并且越来越多地用于不仅扩展，而且用于编程内核的整个组件，同时保持其运行时的完整性。我们概述了它在实际生产环境中使用的显著优势，并举例说明了当前的应用案例。最后，我们指出了其关键挑战，并探讨了可能的未来发展方向。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>像Linux这样的现代单体式（monolithic）操作系统旨在通用化（general-purpose），满足各类用户的需求。它们定义了必要的抽象概念（necessary abstractions），以安全高效地复用和共享硬件资源。因此，其设计选择在很大程度上影响着应用程序的性能、可扩展性和安全性。</p>
<p>显然，Linux内核采用的单体式设计确实存在代价，比如由于组件紧密耦合而导致的复杂性增加和维护难度加大，更大的攻击面带来的更高安全风险，以及在资源受限环境中灵活性和可扩展性降低。</p>
<p>由于这些挑战，绕过或替换操作系统内核的方法逐渐受到重视。内核旁路解决方案和库操作系统能够针对特定工作负载对整个操作系统栈进行专门化处理，从而带来显著的性能提升。然而，这些解决方案可能会通过完全控制硬件而抑制资源复用，还可能需要重写应用程序逻辑，并放弃诸如安全和隔离模型等传统操作系统的优势。</p>
<p>管理大型机器群的用户非常关心如何从硬件中获取最大性能和利用率，同时希望在像Linux这样久经考验的操作系统内核上运行其生产工作负载，以减轻维护负担。理想情况下，他们希望在不放弃自己熟悉的性能监控，管理和运维工具的情况下，获得与以往方法相当的性能。</p>
<p>为此，另一个方向是探索对指定工作负载定制内核机制和策略，这可能会带来显著的改进。然而，在Linux上实现这一点绝非易事。这涉及到修改内核代码，并将特定工作负载的内核更改部署到大量机器上，由于目标应用程序的种类繁多以及频繁重新部署内核的复杂性，这在大规模部署中是不切实际的。为此，已经开展了各种研究项目，旨在探索更安全的内核扩展方式。例如，VINO（虚拟集成网络操作系统）和SPIN允许用户通过用户定义的函数自定义其内核，SPIN采用Modula-3语言编写，以确保动态加载的模块即安全又高效。另一方面，VINO主要关注如何通过故障隔离技术安全地组合扩展。然而，TockOS（Tock Operating System）是一个较新的项目，它使用Rust语言来提升嵌入式系统微内核设计的安全性和可靠性。与这些通常需要新的操作系统环境或调整的系统不同，eBPF允许直接在像Linux和Windows这样的单体内核中实现动态编程功能。与VINO、SPIN和TockOS等项目不同，这些集成使得eBPF能够在不改变内核结构的情况下开发安全增强功能。eBPF于2014年12月发布的3.18内核版本中引入，它作为一个安全的可编程虚拟机允许在高性能的内核运行时之上。它允许用户编写程序并将其加载到内核中，并在指定的钩子处附加以开始执行。为了确保安全性，每个程序在加载时都会由验证器进行静态检查。为了确保性能，所有程序都会由验证器进行静态检查。为了确保性能，所有程序都会即时（JIT，Just-in-time）编译为本地机器指令。</p>
<p>本质上，eBPF使Linux内核在允许时能够动态编程，同时确保其运行时的完整性不受影响。然而，从其最初发布到本文所基于的6.7版本（于2024年1月发布），目前尚无对Linux内核中eBPF的设计和实现的完整描述。因此，通过本文，我们做出一下贡献：</p>
<ul>
<li>对截至Linux内核6.7版本中eBPF运行时的设计与实现进行全面描述。</li>
<li>对eBPF安全属性的详尽描述（第5节）。</li>
<li>关于eBPF当前设计的局限性和关键挑战的识别（第11节）。</li>
</ul>
<p>本文其余部分的结构安排如下：第2节介绍背景知识，第三节概述eBPF程序。第4节阐述了eBPF的高级编程和执行模型。第6、7、8、9节分别讨论了eBPF程序验证过程中涉及的四个主要阶段。第10节介绍了一些用例，第11节探讨了面临的挑战，最后在第12节总结全文。</p>
<p>为简洁起见，本文余下部分将使用“eBPF”来指代Linux运行时，这在Linux内核社区中较为常见。</p>
<h1 id="背景与设计原则"><a href="#背景与设计原则" class="headerlink" title="背景与设计原则"></a>背景与设计原则</h1><p>近年来，在性能、安全性和可观测性目标方面，对Linux内核进行定制已成为不同行业普遍的需求。过去二十年间，Linux内核定制已从一个边缘化的考虑因素演变为满足各种运营需求的关键所在。</p>
<h2 id="内核定制所面临的挑战"><a href="#内核定制所面临的挑战" class="headerlink" title="内核定制所面临的挑战"></a>内核定制所面临的挑战</h2><p>开发人员在需要直接对Linux内核进行修改时，常常会遇到重大障碍。一下是一些主要的挑战。</p>
<p>Linux在编译期间和运行时都提供了大量的配置选项。然而，这些选项并不能从根本上解决性能瓶颈问题，也无法提供有关内核行为的深入见解。它们适用于调整现有内核策略的参数，但不足以表达新的策略。</p>
<p>在这种情况下，如果需要定制内核，开发人员就需要对内核代码进行修改，和/或编写内核模块。然而，这会使测试和调试变更变得困难很多。对内核进行复杂更改需要对复杂的代码库有深入的了解，从而带来巨大的维护负担。除非这些更改得到内核社区的认可，否则在内核升级时需要将其向前移植，因为内核API不稳定。代码中任何未发现的错误都可能导致系统崩溃并产生服务其瘫痪，这直接导致停机和收入损失。</p>
<p>部署内核变更，即使是最小的内核变更，要在服务器集群中部署也是一项耗时的过程。用新内核替换正在运行的内核会导致机器上承载的工作负载中断，因为这些工作负载必须停止。然后，机器需要重新启动进入新内核，并重新初始化所有服务。这于那些冷启动时间长且启动耗时显著的工作负载来说，这个循环尤其有害。完成所有这些步骤之后，还需要进行广泛的测试阶段来测试和验证这些变更，并修复任何检查到的退化问题。对于每台接收内核更新的服务器，都必须重复这个过程，这使得整个过程成本高昂，将新内核部署到整个集群所需的时间通常以周或月来计算。</p>
<h2 id="替代方法及局限性"><a href="#替代方法及局限性" class="headerlink" title="替代方法及局限性"></a>替代方法及局限性</h2><p>正如第2.1节所述，开发人员在对内核进行更改时会面临复杂性。我们在此讨论了一些替代方法，这些方法有望带来性能提升，但也存在局限性和维护方面的挑战。</p>
<p><strong>完全绕过内核或替换内核（Completeley Bypassing or Replacing the Kernel）</strong>。尽管针对特定工作负载的内核绕过框架和库操作系统在性能方面颇具吸引力，但它们也存在自身的缺点。内核绕过解决方案需要完全控制硬件，并且在忙于轮询时会浪费CPU周期。库操作系统是为特定工作负载量身定制的，需要对代码进行修改才能适应不同的需求。此外，这两种方法都使得两个工作负载难以共存或共享硬件资源，这对某些用户来说是不可接受的。最后，它们需要重写应用程序逻辑，这是一项重大的维护负担。</p>
<p>eBPF通过运行在运行时安全且动态地高效定制Linux内核，从而满足了这些要求，降低了对内核进行更改时引入内核错误的风险，并加快了开发和部署的速度。在eBPF推出之前，内核在网络子系统中有多个针对特定领域的基于寄存器的虚拟机来服务特定用例，但它们都不是通用的。</p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>我们现在概述一下eBPF持续发展和演进背后的关键设计原则。</p>
<p>在内核中托管安全高效的虚拟机允许时环境，能够实现内核的<strong>动态定制（Safe and Dynamic OS Customization）</strong>，其性能可与现有的内核代码相媲美，同时确保内核的完整性在任何情况下都不会收到损害。针对具有受限环境的安全虚拟机进行编程，能够降低对内核进行修改的门槛。这种安全性保障使得将此类程序部署到内核时更具信心，与直接修改内核或内核模块相比，降低了引入可能导致服务中断的内核错误的风险。</p>
<p><strong>快速部署与升级（Rapid Deployment and Upgrades）</strong> 更改内核并在大量服务器上进行部署的成本相当高昂，因为重启一台机器会带来终止并重新初始化服务的开销。在运行时动态将程序加载到内核中，能够实现快速部署，且不会造成任何服务中断。同时，通过在运行时卸载和重新加载程序，修复错误和根据收集到的遥测数据进行迭代改进的速度也会大幅提高。这极大地简化了部署流程，加快了测试和验证内核更改的反馈循环，并加速了开发进程。</p>
<p><strong>与内核集成（Integration with the Kernel）</strong> 虽然程序会连接到内核以引入代替行为，但它们应当能够安全地与现有的内核状态进行交互，并在需要时对其进行操作。同时，如果程序没有需要执行的操作，它们应当能够回退到现有的内核处理过程。这为用户提供了灵活的模型，在需要时可以利用现有的内核实现，而无需在程序中重新实现类似的代码。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>eBPF被定义为一种支持eBPF指令集的抽象虚拟机。该虚拟机具有11个寄存器和一个固定大小的栈。eBPF程序在Linux内核提供的受限虚拟机环境中运行。eBPF指令集是一组小巧但功能多样的64位指令。这些指令提供了广泛的功能，使eBPF程序能够在内核空间中高效地执行各种任务。该指令集支持加法、减法、乘法和位操作（例如，与、或、异或）等 算术运算。此外它还支持加载和存储指令以及包括条件和无条件跳转在内的跳转指令，以改变程序流程，以及函数调用和退出。该指令集还具有原子操作，旨在实现安全的内存访问和修改。这些原子操作确保并发访问不会导致不一致或损坏。</p>
<h2 id="The-eBPF-Runtime"><a href="#The-eBPF-Runtime" class="headerlink" title="The eBPF Runtime"></a>The eBPF Runtime</h2><p>eBPF运行时是一组必要组件，用于将抽象虚拟机及相关实体映射到另一个操作系统或硬件平台上。对于Linux内核而言，内核中的eBPF子系统实现了eBPF运行时，并定义了与之交互的系统调用接口。下面，我们将展示构成eBPF生态系统的关键组件，如图1所示。<br><img src="/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/eb9b4a3c-3300-475b-ab66-2ea70d718fd0.png" alt="image.png"></p>
<p><strong>eBPF字节码（eBPF Bytecode）</strong> eBPF字节码被定义为有限的eBPF指令序列。eBPF虚拟机执行使用eBPF字节码编码的eBPF程序。每个程序由一个或多个子程序（简称subprogs）组成。这些字程序只是类似于函数的字包含字节码单元。程序的执行从主子程序（main）开始。</p>
<p><strong>eBPF用户空间加载器（eBPF Userspace Loader）</strong> eBPF拥有活跃的用户空间加载器生态系统，例如BBC、Bptrace和libbpf，这些加载器通过BPF_PROG_LOAD系统调用将eBPF字节码加载到内核，并将程序附加到相关钩子（hooks），同时管理任何响应的映射。会返回一个文件描述符，它代表已加载的程序，然后可以将其用于将程序附加到特定的内核钩子。在本文中，我们将讨论和阐述的重点放在LLVM工具链，将C前端和libbpf上，它们共同构成了最受欢迎且功能最丰富的参考实现。</p>
<p><strong>eBPF验证器（eBPF Verifier）</strong> 验证器是eBPF系统中的关键组件，它会在字节码被内核接受之前对其进行检查，确保与eBPF相关的安全属性，并且在任何情况下加载程序都不会对内核的完整性和安全性产生负面 影响。</p>
<p><strong>eBPF即时编译器和解释器（eBPF Just-In-Time Compiler and Interpreter）</strong> 在验证过程完成后，程序会使用即时（JIT）编译器编译为本地机器指令。然后内核为加载的程序分配一个文件描述符，简化其与内核中各种执行钩子的连接。在即时编译（JIT）被禁用或不支持的情况下，eBPF解释器承担起程序执行的责任，实时动态地解释和执行字节码。</p>
<p><strong>eBPF挂钩（eBPF Hooks）</strong> eBPF程序的流程由事件决定，当内核或应用程序遇到特定的挂钩时，这些事件就会被执行。这些预定义的挂钩点位于内核的多个位置，涵盖了系统调用，函数入口和出口、网络套接字、跟踪点等多种事件。根据其挂载类型和/或程序类型，程序会被挂载到其应运行的挂钩上。如果预定义的挂钩不符合要求，开发人员可以创建自定义挂钩点，称为内核探测（Kprobes）或用户探测（uprobes）。这些探测使得eBPF程序能够几乎挂载到内核或用户应用程序内的任何位置。</p>
<p><strong>eBPF程序类型（eBPF Program Types）</strong> <code>BPF_PROG_TYPE</code>是对eBPF程序的分类，它决定了程序的功能、输入参数、可执行操作以及在内核中的挂载点。每种程序类型都有其特定的特性，这些特性定义了其行为以及与系统的交互方式。例如，套接字过滤器程序类型<code>BPF_PROG_TYPE_SOCKET_FILTER</code>旨在检查和管理套接字级别的网络数据包。开发人员可以在这些程序中设计自定义逻辑，以根据需要分析和修改传入和传出的数据包。相反，跟踪程序类型<code>BPF_PROG_TYPE_TRACING</code>能够监控内核事件，并提供有关系统运行的有价值信息。这些程序类型及其挂载类型在内核代码库中定义，是创建不同需求的eBPF程序的蓝图。</p>
<p><img src="/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/97168117-cf8a-4348-8f5c-d6f5f72c6587.png" alt="image.png"></p>
<p><strong>eBPF辅助函数（eBPF Helpers）</strong> eBPF辅助函数是eBPF程序可访问的专用函数，能够实现与系统及其上下文的交互。这些辅助函数有助于完成诸如打印调试消息、获取系统启动时间、处理网络数据包以及与eBPF映射进行交互等任务。每种eBPF程序类型都可以访问特定的辅助函数子集，这些子集根据其上下文和需求进行了定制。有关bpf辅助函数的详细信息，请参阅内核提供的文档[1]。</p>
<p><strong>eBPF映射（eBPF Maps）</strong> eBPF映射是一种特定类型的抽象数据结构，例如数组或哈希映射，它有助于用户空间和内核之间的数据交换。在eBPF虚拟机中运行的程序可以通过特定于平台的加载指令访问一个或多个映射。</p>
<h2 id="eBPF对象及其生命周期"><a href="#eBPF对象及其生命周期" class="headerlink" title="eBPF对象及其生命周期"></a>eBPF对象及其生命周期</h2><p>每个eBPF对象在内核中都有一个表现形式，用于管理内核中的eBPF程序，并通过文件描述符向用户空间公开。eBPF对象的生命周期与文件描述符的生命周期相关联。一旦与eBPF对象对应的最后一个文件符被释放，其在内核中的状态也会被释放。为了实现超出进程生命周期的持久性，内核允许将这些文件描述符固定在名为<code>bpffs</code>的特殊伪文件系统上。每次固定操作都会对eBPF对象进行引用，从而延长生命周期。</p>
<p><strong>eBPF程序</strong> 这些对象代表实际加载到内核中的程序。在eBPF验证器验证并即时编译（JIT）程序并创建其内核表示形式后，bpf系统调用的<code>BPF_PROG_LOAD</code>命令会返回一个表示该程序的文件描述符。加载完毕后，该程序即可准备附加到指定的内核钩子上。</p>
<p><strong>eBPF映射</strong> 当创建eBPF程序时，会使用bpf系统调用中的<code>BPF_MAP_CREATE</code>命令来定义映射，该命令会返回一个文件描述符。此描述符在eBPF程序中的伪加载指令用于引用映射。在程序验证期间，验证器会将文件描述符解析为内核中的实际映射对象，并将伪加载指令的目的寄存器视为程序中的eBPF映射指针。</p>
<p><strong>eBPF链接</strong> eBPF链接在确保eBPF探针的生命周期长于触发它们的应用程序的生命周期方面发挥着关键作用。eBPF链接是通过bpf系统调用的<code>BPF_LINK_CREATE</code>命令创建的。该链接使开发人员能够间接的将eBPF程序附加到内核挂钩上，提供了一种比常规直接附加方法更灵活、更持续的方式。与直接附加到挂钩不同，创建eBPF链接将程序附加的生命周期与文件描述符绑定在一起，从而简化了程序引用的管理，并且即使加载它的应用程序意外终止，也能保持探针的允许。与eBPF链接相关的文件描述符控制着它的生命周期。当最后一个文件描述符被关闭时，链接会将其程序从内核钩子中分离出来，从而能够清理资源。只有链接所有者才能分离或更新它，这确保了系统的完整性，并防止了未经授权的修改。</p>
<p><strong>BTF</strong> BTF对象代表从用户空间提交到内核的eBPF程序或映像的BTF类型信息，以便验证器在验证过程中将此类信息与程序或映射关联起来。对于内核及其模块，这些对象会在启动时以及加载任何内核模块时自动创建。我们在第3.4节详细阐述了两BTF如何在其他多个用例中发挥了重要作用。</p>
<h2 id="eBPF指令集"><a href="#eBPF指令集" class="headerlink" title="eBPF指令集"></a>eBPF指令集</h2><p>eBPF指令集是根据eBPF虚拟机来定义的。它支持两种指令编码（64位和128位），通用指令（如算术运算、跳转、调用、加载和存储）以及对11个64位寄存器（r0-r10）的寻址，这些寄存器遵循明确的调用约定，其中r10为只读寄存器，指向栈顶。有关指令集和调用约定的完整正式描述，请参阅eBPF指令集规范。</p>
<p>在整个指令集的设计过程中，所遵循的一个关键原则是保持与实际硬件指令集架构（ISA）的高度等效性，这简化了解释器和即时编译器（JIT）的实现。此外，这种高度等效性使得优化编译器后端能够生成性能接近原生编译程序的eBPF汇编代码。这是因为JIT可以将eBPF指令几乎一对一地映射为本地机器指令，而无需引入任何额外的处理机制来处理这种转换。</p>
<p>将指令集与Linux内核中的eBPF运行时解耦的优势之一在于能够在操作系统之外使用它。eBPF指令集架构（ISA）要么可由硬件直接支持，要么可转换为目标硬件架构。这对计算硬件也具有巨大潜力，因此eBPF运行时可以控制并决定是否进行卸载，因为eBPF运行时可以控制并决定是否进行卸载，而针对特定钩子编写的程序可以采用无感知的方式。Kicinski等人已经展示了将XDP钩子的eBPF程序卸载到可编程网络接口卡（NIC）上，而Lukken等人则探讨了其在计算存储设备中的应用。</p>
<h2 id="BPF类型格式"><a href="#BPF类型格式" class="headerlink" title="BPF类型格式"></a>BPF类型格式</h2><p>BPF类型格式（简称BTF）是一种专门用于eBPF的调试信息格式。它由编译器在编译内核或eBPF程序时生成。除了C类型的信息外，它还包含函数原型信息、类型和声明的自定义注释（这些注释对eBPF验证器具有上下文相关的意义）以及源代码信息，以便更好地进行内省和调试。有关元数据格式的正式描述，请参阅BTF文档。</p>
<p>新的调试信息格式的好处有两方面。首先，内核使用的现有调试信息格式——任意记录格式调试（DWARF），如果嵌入内核映像中，会带来较大的内存消耗开销。这意味着始终在内核中附带调试信息（eBPF验证器可以利用这些信息来丰富其静态分析）是不可行的。其次，为了更好地对eBPF程序和映射进行内省和分析，它们需要提供自己的调试信息，以便验证器进行检查。这意味着要在内核中引入复杂的代码来解析DWARF调试信息，这在维护和安全方面都是不可取的。</p>
<p>BTF解决了所有这些问题。由于其紧凑的表示形式，对于编译器生成的相同内核映像，BTF调试信息的内存消耗比DWARF调试信息少一个数量级。这主要归功于Nakryiko等人设计的激进的去重算法，该算法旨在减少BTF的内存占用。</p>
<p>反过来，这使得BTF总是能与内核和eBPF程序一起打包，而验证器在执行静态分析时会大量以来这些信息。由于其表示形式更简单，BTF的处理速度也更快，这一点至关重要，因为在运行时会为内核，任何已加载的内核模块以及所有提供BTF信息的eBPF程序和映射创建内核中的表示形式。</p>
<p>我们现在通过BTF的主要用例来说明其优势。</p>
<p><strong>验证（Verification）</strong> BTF的主要使用者是eBPF验证器。它利用内核的BTF信息来确保eBPF程序对所获取内核指针的类型安全。验证器会通过BTF检查类型信息以确定其可以访问和内省结构体类型的成员。</p>
<p><strong>注释（Annotations）</strong> BTF可以为内核或程序中使用的函数和变量的类型及声明携带自定义注释。这些注释用于为类型附加上下文相关的含义，以辅助验证。</p>
<p><strong>调试（Debugging）</strong> 在eBPF程序和映射中使用BTF可以实现更好的内省和可调式性。在分析程序时，验证器可以将其源代码和行信息打印到日志中，这在程序因用户输出被拒绝时非常有用。它还允许使用源信息对eBPF字节码和JIT编译代码进行注释。这于eBPF映射，通过识别其BTF中的数据类型，可以使其数据转储具有结构性。</p>
<p><strong>编译一次，随处运行（CO-RE，Compile Once Run Everywhere）</strong> CO-RE是eBPF程序的一组重定位的统称。这些重定位通过该结构体成员的内存访问、命名枚举常量值和命名内核配置选项的符号引用进行编码，使编译后的程序更具可移植性。所有这些重定位在加载程序时均由验证器或libbpf解决。这种动态解析确保来eBPF程序能够适应不同的内核版本和架构，而无需重新编译。</p>
<h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><p>在本节中，我们将说明eBPF的高级编程和执行模型。图3展示了从头到尾和执行我们所选实例的eBPF程序所设计的整个流程。</p>
<p><img src="/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/9e2a8dbc-f831-4538-b1bd-66e3252c4cad.png" alt="image.png"></p>
<p>用户通常从步骤<em><strong>s1</strong></em>开始，使用高级编程语言编写一个eBPF程序。在我们的示例只能够，考虑的是为XDP钩子编写的C程序（见Listing 1)，该程序在网络设备驱动程序层处理网络数据包之前被调用。类型为<code>struct xdp_md</code>的<code>ctx</code>参数代表程序可访问的原始网络数据包。<code>data</code>和<code>data_end</code>指针变量分别指向网络数据包数据区域的起始位置和结束位置。通过比较<code>data</code>和<code>data_end</code>的条件分支来确保有足够的空间，以保证对数据包数据的内存访问是安全的。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 1: an example BPF program for the XDP hook,</span></span><br><span class="line"><span class="comment">// which drops all incoming IPv4 UDP traffic</span></span><br><span class="line"></span><br><span class="line">SEC(*xdp*)</span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_program</span><span class="params">(<span class="keyword">struct</span> xdp_md *ctx)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">void</span> *data_end = (<span class="type">void</span> *)(<span class="type">long</span>)ctx-&gt;data_end;</span><br><span class="line">    <span class="type">void</span> *data = (<span class="type">void</span> *)(<span class="type">long</span>)ctx-&gt;data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> =</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eth + <span class="number">1</span> &lt; data_end){</span><br><span class="line">        <span class="keyword">if</span> (eth-&gt;h_proto == bpf_htons(ETH_P_IP))</span><br><span class="line">        {</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> =</span> (<span class="type">void</span> *)(eth + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (iph + <span class="number">1</span> &lt; data_end &amp;&amp; iph-&gt;protocol ==IPPROTO_DUP)</span><br><span class="line">                <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> XDP_PASS</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//data 报文在DMA缓冲区中的起始地址</span></span><br><span class="line"><span class="comment">//data_end 报文在DMA缓冲区中的结束地址</span></span><br><span class="line"><span class="comment">//long 是为了消除verifier对32位截断的警告</span></span><br><span class="line"><span class="comment">//在C里 eth+1 指针步进一个 sizeof(struct ethhdr)的大小，即14字节</span></span><br></pre></td></tr></tbody></table></figure>
<p>下一步<em><strong>S2</strong></em>涉及将此C语言代码进行编译。使用LLVM工具链中的clang编译器将程序编译为对象文件。编译的目标选择为bpf，这指示编译器使用eBPF后端为生成的对象文件生成二进制代码。</p>
<p>步骤<em><strong>S3</strong></em>关注的是对生成的目标文件进行处理，并通过<code>bpf(2)</code>系统调用将其中编程的程序提交给内核以进行加载。在我们的示例中，我们使用bpftool用户空间工具，该工具又借助libbpf库来执行程序的加载操作。一旦目标文件处理完毕且程序已从其中提取出的信息在步骤<em><strong>S4</strong></em>中提交内核。通过使用<code>bpf(2)</code>系统调用的<code>BPF_PROG_LOAD</code>命令调用eBPF验证器。</p>
<p>eBPF验证器随后会对程序进行验证，以确定其在内核中执行是否安全。如果验证器无法确定程序的安全性，则会拒绝该程序并向用户空间返回错误。否则，验证成功的程序会被即时编译，并将与eBPF程序对应的文件描述符返回给用户空间。</p>
<p>一旦用户空间获取来该文件的描述符，它现在就可以链接到网络设备的XDP钩子上。例如，网络设备名为eth0，步骤<em><strong>S5</strong></em>涉及调用<code>bpf(2)</code>系统调用的<code>BPF_LINK_CREATE</code>命令，将程序附加到网络设备。如果该命令的参数均有效，则内核会将与eBPF链接对应的文件描述符返回给用户空间。</p>
<p>此时，eBPF程序已经加载到eth0网络接口，并拒绝所有针对该接口传入的IPv4 UDP流量。它会在内核网络设备驱动程序接收到的每一个原始网络数据包时被调用，并对其进行处理。其余流量则会传递到内核的网络栈。</p>
<p>在步骤<em><strong>S6</strong></em>中，一旦用户空间应用程序关闭了eBPF链接的文件描述符，程序与网络接口将分离。一旦eBPF程序文件在步骤<em><strong>S7</strong></em>中被关闭文件描述符后，内核将会释放它所占用的资源，例如其代码所需的内存。</p>
<h1 id="eBPF程序的安全性"><a href="#eBPF程序的安全性" class="headerlink" title="eBPF程序的安全性"></a>eBPF程序的安全性</h1><p>程序安全性是eBPF程序的一个关键方面，它确保程序能够正确且安全地执行，同时不会损害Linux内核的稳定性和安全性。在eBPF程序的语境中，程序安全性指的是为保护内核运行时的完整性以及维护eBPF程序执行所在的内核上下文的不变形而必须满足的一系列属性。违反这些安全属性的程序在加载到内核时应被拒绝。</p>
<p>[1]:bpf-helpers(7) — Linux manual page. <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">https://man7.org/linux/man-pages/man7/bpf-helpers.7.html</a>. Accessed:2024-06-09.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://jiuzhao14.github.io">wesley tian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://jiuzhao14.github.io/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/">http://jiuzhao14.github.io/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://jiuzhao14.github.io" target="_blank">wesley's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/eBPF/">eBPF</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/12/08/C/" title="C"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C</div></div><div class="info-2"><div class="info-item-1">在 C 语言中，typedef struct {} ; 和 typedef struct attribute(()) {} ; 的核心区别在于：后者使用了 GCC（或 Clang）的扩展语法 attribute 来为结构体附加编译器属性（attributes），而前者是标准 C 的普通结构体定义。 一、基本形式对比 普通结构体（标准 C）  1234typedef struct {int a;char b;} MyStruct; 符合 ISO C 标准编译器按默认规则处理对齐、大小、布局等  带 attribute 的结构体（GCC/Clang 扩展）  1234typedef struct __attribute__((packed)) {int a;char b;} MyStruct; 使用了编译器特定的 attribute 语法可以控制结构体的内存布局、对齐方式、警告行为等⚠️ attribute 是 GCC 和 Clang 支持的扩展，不是标准 C 的一部分。在 MSVC 等其他编译器中不支持（MSVC 用 #pragma pack 或 __declspec 实现类似功能...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">wesley tian</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.</span> <span class="toc-text">背景与设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AE%9A%E5%88%B6%E6%89%80%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">2.1.</span> <span class="toc-text">内核定制所面临的挑战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95%E5%8F%8A%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">替代方法及局限性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.3.</span> <span class="toc-text">设计原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#The-eBPF-Runtime"><span class="toc-number">3.1.</span> <span class="toc-text">The eBPF Runtime</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eBPF%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.2.</span> <span class="toc-text">eBPF对象及其生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eBPF%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">3.3.</span> <span class="toc-text">eBPF指令集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BPF%E7%B1%BB%E5%9E%8B%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">BPF类型格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#eBPF%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">eBPF程序的安全性</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/08/C/" title="C">C</a><time datetime="2025-12-08T07:50:36.000Z" title="发表于 2025-12-08 15:50:36">2025-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/" title="The eBPF Runtime in the Linux Kernel">The eBPF Runtime in the Linux Kernel</a><time datetime="2025-11-02T15:49:03.000Z" title="发表于 2025-11-02 23:49:03">2025-11-02</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By wesley tian</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><div class="js-pjax"></div></div></body></html>