<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wesley&#39;s Blog</title>
  
  
  <link href="http://jiuzhao14.github.io/atom.xml" rel="self"/>
  
  <link href="http://jiuzhao14.github.io/"/>
  <updated>2025-12-29T01:45:29.144Z</updated>
  <id>http://jiuzhao14.github.io/</id>
  
  <author>
    <name>wesley tian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Introduction to Probability for Data Science</title>
    <link href="http://jiuzhao14.github.io/2025/12/29/Introduction-to-Probability-for-Data-Science/"/>
    <id>http://jiuzhao14.github.io/2025/12/29/Introduction-to-Probability-for-Data-Science/</id>
    <published>2025-12-29T01:14:12.000Z</published>
    <updated>2025-12-29T01:45:29.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction-to-Probability-for-Data-Science"><a href="#Introduction-to-Probability-for-Data-Science" class="headerlink" title="Introduction to Probability for Data Science"></a>Introduction to Probability for Data Science</h1><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>Probabiliby is one of the most interesting subjects in electrical engineering and computer science. It bridges our favorite engineering principles to the practical reality, a world that is full of uncertainty. </p><h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><h3 id="Mathematical-Background"><a href="#Mathematical-Background" class="headerlink" title="Mathematical Background"></a>Mathematical Background</h3><p>“Data science” has different meanings to different people. If you ask a biologist, data science could mean analyzing DNA sequences. If you ask a banker, data science could mean predicting the stock market. If you ask a software engineer, data science could mean programs and data structures; if you ask a machine learning scientist, data science could mean programs and algorithms. However, one thing that is common in all these disciplines is the concept of uncertainty. We choose to learn from data because we believe that the latent information is embedded in the data – unprocessed, contains noise, and could have missing entries. If there is no randomness, all data scientists can close their business because there is simply no problem to solve. However, the moment we see randomness, our business comes back. Therefore, data science is the subject of making decisions in uncertainty.</p><blockquote><p>“数据科学”对不同的人有着不同的含义。如果你问一位生物学家，数据科学可能意味着分析DNA序列；如果你问一位银行家，数据科学可能意味着预测股票市场；如果你问一位软件工程师，数据科学可能意味着程序与数据结构；而如果你问一位机器学习科学家，数据科学可能意味着程序与算法。然而，所有这些领域有一个共同点，那就是不确定性的概念。我们之所以选择从数据中学习，是因为我们相信潜在的信息就隐藏在数据之中——这些数据未经处理、包含噪声，还可能存在缺失值。如果没有随机性（不确定性），所有数据科学家都可以关门歇业了，因为根本不存在需要解决的问题。但一旦我们观察到随机性，我们的“生意”就又回来了。因此，数据科学本质上是一门在不确定性中做出决策的学科。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction-to-Probability-for-Data-Science&quot;&gt;&lt;a href=&quot;#Introduction-to-Probability-for-Data-Science&quot; class=&quot;headerlink&quot; title=&quot;Intr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CEL-200 COMTECH</title>
    <link href="http://jiuzhao14.github.io/2025/12/16/CEL-200-COMTECH/"/>
    <id>http://jiuzhao14.github.io/2025/12/16/CEL-200-COMTECH/</id>
    <published>2025-12-16T07:42:00.000Z</published>
    <updated>2025-12-29T00:58:56.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>SCPC</strong><br>在卫星通信中，SCPC（Single Channel Per Carrier，单路单载波）是一种经典的频分多址（FDMA）传输技术，其核心作用是为点对点通信提供高可靠性、低时延、专用带宽的卫星链路。</p><p><strong>基本原理</strong></p><ul><li>单个载波仅承载一路通信信号。</li><li>每队通信站点使用一对独立的上行/下行载波频率进行全双工通信</li><li>载波之间通过频率隔离，避免相互干扰</li></ul><p><strong>主要作用</strong></p><ol><li>实现高可靠、电信级通信</li><li>支持低时延通信</li><li>按需分配带宽（结合DAMA）</li></ol><ul><li>在SCPC/DAMA（Demand Assigned Multiple Access）系统中：<ul><li>无通信时关闭载波，节省卫星功率；</li><li>有通信需求时动态申请并开启载波。</li></ul></li><li>特别适合远端站数量多、单站流量小且突发性强的移动卫星系统。</li></ul><ol start="4"><li>简化调试解调器设计<ul><li>每个载波只处理单一信号，调制解调器结构简单，易于实现高阶调制（如QPSK、8PSK）和高效功放利用。</li></ul></li></ol><p><strong>与其他技术对比</strong></p><table><thead><tr><th><strong>技术</strong></th><th><strong>多址方式</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td>SCPC</td><td>FDMA（每载波一路）</td><td>点对点、高可靠、恒定速率业务</td></tr><tr><td>MCPC（多路单载波）</td><td>FDM+TDM（多路复用到一个载波）</td><td>广播、集中回传（如电视分发）</td></tr><tr><td>TDMA</td><td>时分多址</td><td>多用户共享、突发数据（如现代VSAT宽带网）</td></tr><tr><td>MF-TDMA</td><td>混合多址</td><td>宽带卫星互联网（如Starlink地面段）</td></tr></tbody></table><h2 id="Modes-of-operation"><a href="#Modes-of-operation" class="headerlink" title="Modes of operation"></a>Modes of operation</h2><h3 id="SCPC"><a href="#SCPC" class="headerlink" title="SCPC"></a>SCPC</h3><p>SCPC mode of operation helps to establish “point to point” links between a pair of stations (see figure 15). In such a link, each station transmits a dedicated carrier received by the other station. The links can be of any asymmetry and can even be transmitted via different transponders or satellites.</p><p>When using the SCPC mode of operation, it is necessary to pre-set the appropriate routers. Each device is configures separately using its WEB-based interface.</p><blockquote><p>SCPC 操作模式有助于在一对站点之间建立“点对点”链路（见图 15）。在这种链路中，每个站点都传输一个专用载波，由另一站点接收。这些链路可以是任意不对称的，甚至可以通过不同的转发器或卫星进行传输。<br>在使用 SCPC 操作模式时，必须预先设置合适的路由器。每个设备都通过其基于网络的界面单独进行配置。</p></blockquote><p><img src="/2025/12/16/CEL-200-COMTECH/scpc_channel.png" alt="image.png"></p><h3 id="SCPC-DAMA"><a href="#SCPC-DAMA" class="headerlink" title="SCPC-DAMA"></a>SCPC-DAMA</h3><p>The forward SCPC link is primarily used to control the stations, however, it can be also used to deliver a user data to the stations. Only the packets that are addressed to the station recipients are routed towards the LAN interface of the CEL router. Capacity of the forward link is dynamically allocated between the stations based on the current traffic and established rules for priority and traffic distribution.</p><p>The stations transmit their user data via SCPC links allocated by the Hub. A separate CEL router is needed in the Hub to receive each return SCPC link.</p><p>Typically, SCPC-DAMA mode is used in networks, which require high-throughput communication links from the stations to the Hub.</p><blockquote><p>前向 SCPC 链路主要用于控制站点，但也可用于向站点传送用户数据。只有发往站点接收方的数据包才会被路由到 CEL 路由器的局域网接口。前向链路的容量会根据当前流量以及已设定的优先级和流量分配规则在各站点之间动态分配。<br>各站点通过由中心分配的单载波频分多路复用（SCPC）链路传输其用户数据。中心需要单独的电路交换路由器来接收每个返回的单载波频分多路复用链路。<br>通常，在需要从各站点到中心站的高吞吐量通信链路的网络中，会使用单载波频分多址（SCPC-DAMA）模式。</p></blockquote><p><img src="/2025/12/16/CEL-200-COMTECH/scpc_dama.png" alt="image.png"></p><h2 id="Routing-and-switching"><a href="#Routing-and-switching" class="headerlink" title="Routing and switching"></a>Routing and switching</h2><h3 id="SVLAN-overview"><a href="#SVLAN-overview" class="headerlink" title="SVLAN overview"></a>SVLAN overview</h3><p>CEL路由器使用一种特殊的协议通过卫星传输数据。这种协议的要求如下：头部信息最少以及能够分割和分组数据流。CEL路由器将此协议称为SVLAN。SVLAN信道类似于以太网中的VLAN概念。它们可以被视为具有指定编号的“数据管道”。在调制器中将流量传输到这样的“管道”（SVLAN）后，如果接收器设置了相同的SVLAN编号，这些数据包将被接受并由IP路由器进一步处理。多个网络可以通过路由器到单个SVLAN（每个网络具有其自身的优先级）。SVLAN会在每个数据包中添加两个字节。</p><p><img src="/2025/12/16/CEL-200-COMTECH/structure_of_bbframe.png" alt="image.png"></p><p><img src="/2025/12/16/CEL-200-COMTECH/cel_routing.png" alt="image.png"></p><table><thead><tr><th>CEL 命令/路由表象</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>TX map</td><td>向卫星传输的流量</td><td></td></tr><tr><td></td><td>VLAN</td><td>此<strong>IP map</strong>命令将针对由该<strong>VLAN</strong>标签标记的本地网络所接收的流量运行。</td></tr><tr><td></td><td>IP Network</td><td>主机/网络地址</td></tr><tr><td></td><td>Netmask</td><td>主机/网络掩码</td></tr><tr><td></td><td>SVLAN</td><td>为此流量分配的 SVLAN</td></tr><tr><td></td><td>Station</td><td>站点编号，流量会被视为该站点的传输流量计入统计（此参数无其他功能）。</td></tr><tr><td></td><td>Priority</td><td>流量的优先级（ml-低，mm-中，mh-高）</td></tr><tr><td></td><td>Policy</td><td>为处理流量而分配的策略</td></tr><tr><td></td><td>Shaper channel</td><td>用于流量处理的整形通道</td></tr><tr><td></td><td>Title</td><td>名称</td></tr><tr><td>Svlan receive</td><td>从卫星接收的 SVLAN 流量</td><td></td></tr><tr><td></td><td>VLAN</td><td>为传输到本地网络的流量设置 VLAN 标签</td></tr><tr><td></td><td>SVLAN</td><td>从卫星接收的SVLAN</td></tr><tr><td></td><td>Title</td><td>名称</td></tr><tr><td>IP address</td><td>路由器地址空间的分配（一个路由器可能拥有不止一个 IP 地址）</td><td></td></tr><tr><td></td><td>VLAN</td><td>CEL 路由器地址所属的 VLAN</td></tr><tr><td></td><td>IP-address</td><td>CEL 路由器的本地地址</td></tr><tr><td></td><td>Netmask</td><td>网络掩码</td></tr><tr><td></td><td>Local access</td><td>通过本地网络配置对网络界面的访问权限</td></tr><tr><td></td><td>Title</td><td>名称</td></tr><tr><td>Static route</td><td>CEL 路由器局域网接口之外的网络流量传输</td><td></td></tr><tr><td></td><td>VLAN</td><td>VLAN。此路由将用于处理带有指定 VLAN 标记的流量。</td></tr><tr><td></td><td>IP network</td><td>主机/网络地址</td></tr><tr><td></td><td>Netmask</td><td>主机/网络掩码</td></tr><tr><td></td><td>Gateway</td><td>访问此类网络/主机的网关 IP 地址</td></tr><tr><td></td><td>Title</td><td>名称</td></tr><tr><td>VLAN bridge</td><td>以太网流量向卫星的传输（第二层桥接）。</td><td></td></tr><tr><td></td><td>VLAN</td><td>VLAN。此桥接映射命令将针对来自本地网络且带有此 VLAN 标记的流量运行。</td></tr><tr><td></td><td>SVLAN</td><td>为此流量分配的 SVLAN</td></tr><tr><td></td><td>Station</td><td>站点编号，流量会被视为该站点的传输流量计入统计（此参数无其他功能）。</td></tr><tr><td></td><td>Priority</td><td>流量的优先级（ml-低，mm-中，mh-高）</td></tr><tr><td></td><td>Policy</td><td>为处理流量而分配的策略</td></tr><tr><td></td><td>Traffic shaper</td><td>分配用于流量处理的流量整形器。</td></tr><tr><td></td><td>Title</td><td>名称</td></tr></tbody></table><h3 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h3><h3 id="Internal-Time"><a href="#Internal-Time" class="headerlink" title="Internal Time"></a>Internal Time</h3><h3 id="TCP-acceleration"><a href="#TCP-acceleration" class="headerlink" title="TCP acceleration"></a>TCP acceleration</h3><p>The CEL TCP acceleration algorithm includes the ACK spoofing, window and header compression. The ACK spoofing allows reducing delays that result from high latency by spoofed ACKs sent to the source without waiting for respective acknowledgment from the remote end. CEL buffers respective data packets in Tx queue (TXQ) and takes responsibility for delivering those packets successfully (see Figure 19).</p><p>The first TCP packets of the session are delivered to the destination without TCP acceleration. During transmission of such packets CEL routers 1 and 2 story locally the TCP/IP header of the transmitted packet. This TCP/IP header will be replaced in further transmissions by a compact session identifier (12 bytes) and restored on the remote end.</p><p>Using TCP-acceleration mechanism can significantly reduce the waiting time of confirmation of delivery of transmitted packets. Receving this acknowledgment, the sender information needed to guarantee delivery of data as well as receive it signals the need to transfer the next set of packets within the session established communication between the sender and the recipient.</p><p>If there is insufficient bandwidth satellite link CEL one router, the sender may signal information about the need to reduce the data rate is provided indicating the size of the window in the TCP-ACK - packets generated on the sender side of the router (CEL one router).</p><p>Thus, reducing waiting time confirmation of delivery, provides increased data rate within an establised session. This package delivery guarantee is provided by routers CEL.</p><p>The first TCP packets that initiate the TCP connections delivered without the use of acceleration and with the original headers that will be locally stored and replaced by a compact (12 bytes) proprietary header in further data exchange. Next data packets will be sent with such proprietary header and will be stored in TxQ of the source CEL untill respective acknowledgement of the destination CEL. The destination CEL replaces proprietary headers by the original ones and route this packet to the recipient. Upon ACK reception from the destination the respective packet will be removed from the RxQ of the destination CEL. The TxQ and RxQ queues allow retransmission of packets that have been damaged or lost during transmission via the satellite or Ethernet links.</p><p>The CEL router optimizes data rate of the Source by managing its TCP window size via ACK replies.</p><blockquote><p>CEL TCP加速算法包括ACK欺骗、窗口和头部压缩。ACK欺骗通过在未等待远程端相应确认的情况下向源端发送欺骗ACK来减少高时延导致的延迟。CEL在发送队列（TXQ）中缓冲相应的数据包，并负责成功交付这些数据包（见图 19）。<br>会话的第一个TCP数据包在传输时不使用TCP加速。在传输此类数据包时，CEL路由器1和2会在本地存储所传输数据包的TCP/IP报头。在后续传输中，此 TCP/IP报头将被紧凑的会话标识符（12 字节）所替代，并在远程端恢复。<br>使用TCP加速机制可以显著减少已传输数据包的确认交付等待时间。接收方收到此确认后，发送方获取保证数据交付所需的信息，并收到传输下一组数据包的信号，从而在发送方和接收方之间建立的会话通信中进行传输。<br>如果卫星链路中路由器的带宽不足，发送方可能会在路由器发送端生成的TCP-ACK数据包中发出信号，表明需要降低数据传输速率，并指示窗口大小。<br>因此，减少等待时间确认交付，可在已建立的会话中提供更高的数据传输速率。此报文交付保证由CEL路由器提供。<br>建立TCP连接时发出的首批TCP数据包未使用加速功能，且保留原始报头，这些原始报头将在本地存储，并在后续数据交换中由一个紧凑的（12 字节）专有报头替代。接下来的数据包将使用这种专有报头发送，并存储在源CEL的发送队列（TxQ）中，直到目的地CEL发出相应确认。目的地CEL将专有报头替换为原始报头，并将数据包路由给接收方。在从目的地接收到确认后，相应的数据包将从目的地CEL的接收队列（RxQ）中移除。发送队列和接收队列允许在通过卫星或以太网链路传输过程中受损或丢失的数据包重新传输。<br>CEL路由器通过ACK回复管理源端的TCP窗口大小来优化其数据传输速率。</p></blockquote><p><img src="/2025/12/16/CEL-200-COMTECH/tcp_acceleration.png" alt="image.png"></p><h3 id="TCP-Acceleration-settings"><a href="#TCP-Acceleration-settings" class="headerlink" title="TCP Acceleration settings"></a>TCP Acceleration settings</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th><th><strong>范围</strong></th></tr></thead><tbody><tr><td>Enable</td><td>Turning TCP-acceleration on/off</td><td>On/Off</td></tr><tr><td>Tcpa_verison</td><td>CEL Stations SW version compatibility mode</td><td>V3_5/V3_4</td></tr><tr><td>Allow from SVLAN(1-64000)</td><td>Range of SVLANs where the traffic will be accelerated.</td><td>1…64000</td></tr><tr><td>Allow to SVLAN(1-65000)</td><td>Traffic transmitting via SVLAN out of this range will not be accelerated</td><td>1…64000</td></tr><tr><td>MSS</td><td>Maximum size of a useful data block in bytes for a TCP packet(segment)</td><td>100…1500bytes</td></tr><tr><td>Max TCP window</td><td>TCP window size when transmitting the data. Bigger window size increases channel capacity thus significantly increasing the load to the relevant routers</td><td>1000…65535bytes</td></tr><tr><td>TCP rcv.wnd update</td><td>The update period for the estimated TCP-window size. As the queue fills/empties the size of the TCP-window changes. This parameter affects the rate of change of the TCP-window.</td><td>50-500</td></tr><tr><td>Number of sessions</td><td>The maximum number of open and active sessions. If this number of sessions is exceeded (i.e all the queues are full), the next session will open wihout TCP acceleration.</td><td>10-56000</td></tr><tr><td>Minimum buffers coefficient</td><td>This Coefficient affects the relationship between TCP window size and the number of free buffers within the system. The greater this factor, the more buffers remain in use for tasks outside of the acceleration subsystem.</td><td>4-32</td></tr><tr><td>Max queue len</td><td>Maximum queue length in packets. This is the total maximum queue length for each session (TxQ and TxQ) and will not exceed this value.</td><td>1-5000</td></tr><tr><td>Max mode queue len</td><td>The maximum modulator queue length (in packets) for acceleration purposes. The accelerating subsystem will not exceed this number of packets to the modulator.</td><td>5-5000</td></tr><tr><td>Retransmit timeout</td><td>The time interval prior to the packet being resent, if there was no confirmation that the packet was received.</td><td>1-255, seconds</td></tr><tr><td>Retransmit max tries</td><td>The maximum number of retry attempts. After exceeding this value the TCP acceleration session will be closed.</td><td>1-255</td></tr><tr><td>Session inactivity timeout</td><td>If no data is transmitted during this time, the session is closed.</td><td>1-255, minutes</td></tr><tr><td>ACK period</td><td>The time period in which acknowledgements are sent to the modulator.</td><td>4-500</td></tr></tbody></table><p><strong>iperf3流量测试，RTT、window scaling和throughput</strong></p><p><strong>RTT</strong></p><p><img src="/2025/12/16/CEL-200-COMTECH/rtt_normal.jpg" alt="image.png"></p><p><img src="/2025/12/16/CEL-200-COMTECH/rtt_tcp_acc.jpg" alt="image.png"></p><p><strong>window_scaling</strong></p><p><img src="/2025/12/16/CEL-200-COMTECH/window_scaling_normal.jpg" alt="image.png"></p><p><img src="/2025/12/16/CEL-200-COMTECH/window_scaling_tcp_ac.jpg" alt="image.png"></p><p><strong>throughput</strong></p><p><img src="/2025/12/16/CEL-200-COMTECH/throughput_normal.jpg" alt="image.png"></p><p><img src="/2025/12/16/CEL-200-COMTECH/throughput_tcp_acc.jpg" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;SCPC&lt;/strong&gt;&lt;br&gt;在卫星通信中，SCPC（Single Channel Per Carrier，单路单载波）</summary>
      
    
    
    
    
    <category term="CEL200" scheme="http://jiuzhao14.github.io/tags/CEL200/"/>
    
  </entry>
  
  <entry>
    <title>C</title>
    <link href="http://jiuzhao14.github.io/2025/12/08/C/"/>
    <id>http://jiuzhao14.github.io/2025/12/08/C/</id>
    <published>2025-12-08T07:50:36.000Z</published>
    <updated>2025-12-09T01:52:57.872Z</updated>
    
    <content type="html"><![CDATA[<p>在 C 语言中，typedef struct {} ; 和 typedef struct <strong>attribute</strong>(()) {} ; 的核心区别在于：后者使用了 GCC（或 Clang）的扩展语法 <strong>attribute</strong> 来为结构体附加编译器属性（attributes），而前者是标准 C 的普通结构体定义。</p><h2 id="一、基本形式对比"><a href="#一、基本形式对比" class="headerlink" title="一、基本形式对比"></a>一、基本形式对比</h2><ol><li>普通结构体（标准 C）</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line">} MyStruct;</span><br></pre></td></tr></tbody></table></figure><p>符合 ISO C 标准<br>编译器按默认规则处理对齐、大小、布局等</p><ol><li>带 <strong>attribute</strong> 的结构体（GCC/Clang 扩展）</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>)) {</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line">} MyStruct;</span><br></pre></td></tr></tbody></table></figure><p>使用了编译器特定的 <strong>attribute</strong> 语法<br>可以控制结构体的内存布局、对齐方式、警告行为等<br>⚠️ <strong>attribute</strong> 是 GCC 和 Clang 支持的扩展，不是标准 C 的一部分。在 MSVC 等其他编译器中不支持（MSVC 用 #pragma pack 或 __declspec 实现类似功能）。</p><h2 id="二、常见的-attribute-用于结构体的选项"><a href="#二、常见的-attribute-用于结构体的选项" class="headerlink" title="二、常见的 attribute 用于结构体的选项"></a>二、常见的 <strong>attribute</strong> 用于结构体的选项</h2><p>属性 作用</p><hr><p><strong>attribute</strong>((packed)) 取消默认对齐，让成员紧密排列，节省空间（但可能降低访问速度）<br><strong>attribute</strong>((aligned(n))) 强制结构体按 n 字节对齐（如 aligned(16)）<br><strong>attribute</strong>((deprecated)) 使用该结构体时产生警告<br><strong>attribute</strong>((may_alias)) 允许类型双关（type punning），常用于底层编程</p><h2 id="三、重点示例：packed-的影响"><a href="#三、重点示例：packed-的影响" class="headerlink" title="三、重点示例：packed 的影响"></a>三、重点示例：packed 的影响</h2><p>普通结构体（默认对齐）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="type">char</span> a; <span class="comment">// 1 byte</span></span><br><span class="line"><span class="type">int</span> b; <span class="comment">// 4 bytes，前面补3字节对齐</span></span><br><span class="line">} S1;</span><br></pre></td></tr></tbody></table></figure><p>sizeof(S1) = 8 字节（在 32/64 位系统上）<br>packed 结构体：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>)) {</span></span><br><span class="line"><span class="type">char</span> a; <span class="comment">// 1 byte</span></span><br><span class="line"><span class="type">int</span> b; <span class="comment">// 紧跟其后，无填充</span></span><br><span class="line">} S2;</span><br></pre></td></tr></tbody></table></figure><p>sizeof(S2) = 5 字节<br>但访问 b 可能触发 非对齐访问，在某些架构（如 ARM、RISC-V）上会 引发硬件异常或性能下降</p><h2 id="四、语法细节"><a href="#四、语法细节" class="headerlink" title="四、语法细节"></a>四、语法细节</h2><p>正确写法（注意位置）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 推荐：属性紧跟在 struct 关键字后</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>)) {</span></span><br><span class="line">...</span><br><span class="line">} MyStruct;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误：不能写成</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">...</span><br><span class="line">} __attribute__((packed)) MyStruct; <span class="comment">// 虽然某些编译器接受，但语义不同（作用于 typedef 名，而非 struct 类型本身）</span></span><br></pre></td></tr></tbody></table></figure><p>更严谨的做法是同时给结构体标签和 typedef 加属性（如果需要）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>)) <span class="title">my_struct</span> {</span></span><br><span class="line"><span class="type">char</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> <span class="title">my_struct_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="五、可移植性建议"><a href="#五、可移植性建议" class="headerlink" title="五、可移植性建议"></a>五、可移植性建议</h2><p>如果代码需要跨编译器（如 Windows + MSVC），应避免直接使用 <strong>attribute</strong><br>可用宏封装提高兼容性：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKED_STRUCT __attribute__((packed))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKED_STRUCT</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PACKED_STRUCT</span> {</span></span><br><span class="line"><span class="type">char</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">} MyStruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>总结</p><p>对比项 typedef struct {} typedef struct <strong>attribute</strong>(()) {}</p><hr><p>标准性 ✅ ISO C 标准 ❌ GCC/Clang 扩展<br>功能 默认内存布局 可控制对齐、打包、警告等<br>常见用途 通用结构体 嵌入式、协议解析、硬件寄存器映射等需精确内存布局的场景<br>风险 无 可能导致非对齐访问、可移植性差</p><p>sdpk文件系统 dpdk用户态协议栈 异步网络库zvnet 协程 io_uring Nginx bpf 线程池 内存池 连接池 原子操作 ringbuffer 定时器 死锁检测 分布式锁</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 C 语言中，typedef struct {} ; 和 typedef struct &lt;strong&gt;attribute&lt;/strong&gt;(()) {} ; 的核心区别在于：后者使用了 GCC（或 Clang）的扩展语法 &lt;strong&gt;attribute&lt;/stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>The eBPF Runtime in the Linux Kernel</title>
    <link href="http://jiuzhao14.github.io/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/"/>
    <id>http://jiuzhao14.github.io/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/</id>
    <published>2025-11-02T15:49:03.000Z</published>
    <updated>2025-11-02T15:56:08.516Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Linux内核中的eBPF运行时环境</strong></p><blockquote><p>翻译文献The eBPF Runtime in the Linux Kernel</p></blockquote><p><strong>摘要</strong><br>扩展伯克利数据包过滤器（eBPF，Extended Berkeley Packet Filter）是一种运行时环境，它允许用户将程序加载到操作系统（如Linux或Windows)的内核中，并在指定的内核钩子处安全高效地执行这些程序。每个程序都要经过一个验证器（校验器），验证器会推断出其执行的安全保证。在内核中托管一个安全的虚拟机允许时环境，使其能够动态编程。与绕过内核或完全替代内核的流行方法不同，eBPF为用户提供了灵活性，使其能够即时修改内核，快速实验和迭代，并部署解决方法以满足特定工作负载的需求，同时与内核协同工作。</p><p>在本文中，我们首次全面描述了Linux内核中eBPF运行时的设计与实现。我们认为，如今的eBPF为内核提供了一个成熟且安全的编程环境。自其诞生以来，它已被广泛采用，并且越来越多地用于不仅扩展，而且用于编程内核的整个组件，同时保持其运行时的完整性。我们概述了它在实际生产环境中使用的显著优势，并举例说明了当前的应用案例。最后，我们指出了其关键挑战，并探讨了可能的未来发展方向。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>像Linux这样的现代单体式（monolithic）操作系统旨在通用化（general-purpose），满足各类用户的需求。它们定义了必要的抽象概念（necessary abstractions），以安全高效地复用和共享硬件资源。因此，其设计选择在很大程度上影响着应用程序的性能、可扩展性和安全性。</p><p>显然，Linux内核采用的单体式设计确实存在代价，比如由于组件紧密耦合而导致的复杂性增加和维护难度加大，更大的攻击面带来的更高安全风险，以及在资源受限环境中灵活性和可扩展性降低。</p><p>由于这些挑战，绕过或替换操作系统内核的方法逐渐受到重视。内核旁路解决方案和库操作系统能够针对特定工作负载对整个操作系统栈进行专门化处理，从而带来显著的性能提升。然而，这些解决方案可能会通过完全控制硬件而抑制资源复用，还可能需要重写应用程序逻辑，并放弃诸如安全和隔离模型等传统操作系统的优势。</p><p>管理大型机器群的用户非常关心如何从硬件中获取最大性能和利用率，同时希望在像Linux这样久经考验的操作系统内核上运行其生产工作负载，以减轻维护负担。理想情况下，他们希望在不放弃自己熟悉的性能监控，管理和运维工具的情况下，获得与以往方法相当的性能。</p><p>为此，另一个方向是探索对指定工作负载定制内核机制和策略，这可能会带来显著的改进。然而，在Linux上实现这一点绝非易事。这涉及到修改内核代码，并将特定工作负载的内核更改部署到大量机器上，由于目标应用程序的种类繁多以及频繁重新部署内核的复杂性，这在大规模部署中是不切实际的。为此，已经开展了各种研究项目，旨在探索更安全的内核扩展方式。例如，VINO（虚拟集成网络操作系统）和SPIN允许用户通过用户定义的函数自定义其内核，SPIN采用Modula-3语言编写，以确保动态加载的模块即安全又高效。另一方面，VINO主要关注如何通过故障隔离技术安全地组合扩展。然而，TockOS（Tock Operating System）是一个较新的项目，它使用Rust语言来提升嵌入式系统微内核设计的安全性和可靠性。与这些通常需要新的操作系统环境或调整的系统不同，eBPF允许直接在像Linux和Windows这样的单体内核中实现动态编程功能。与VINO、SPIN和TockOS等项目不同，这些集成使得eBPF能够在不改变内核结构的情况下开发安全增强功能。eBPF于2014年12月发布的3.18内核版本中引入，它作为一个安全的可编程虚拟机允许在高性能的内核运行时之上。它允许用户编写程序并将其加载到内核中，并在指定的钩子处附加以开始执行。为了确保安全性，每个程序在加载时都会由验证器进行静态检查。为了确保性能，所有程序都会由验证器进行静态检查。为了确保性能，所有程序都会即时（JIT，Just-in-time）编译为本地机器指令。</p><p>本质上，eBPF使Linux内核在允许时能够动态编程，同时确保其运行时的完整性不受影响。然而，从其最初发布到本文所基于的6.7版本（于2024年1月发布），目前尚无对Linux内核中eBPF的设计和实现的完整描述。因此，通过本文，我们做出一下贡献：</p><ul><li>对截至Linux内核6.7版本中eBPF运行时的设计与实现进行全面描述。</li><li>对eBPF安全属性的详尽描述（第5节）。</li><li>关于eBPF当前设计的局限性和关键挑战的识别（第11节）。</li></ul><p>本文其余部分的结构安排如下：第2节介绍背景知识，第三节概述eBPF程序。第4节阐述了eBPF的高级编程和执行模型。第6、7、8、9节分别讨论了eBPF程序验证过程中涉及的四个主要阶段。第10节介绍了一些用例，第11节探讨了面临的挑战，最后在第12节总结全文。</p><p>为简洁起见，本文余下部分将使用“eBPF”来指代Linux运行时，这在Linux内核社区中较为常见。</p><h1 id="背景与设计原则"><a href="#背景与设计原则" class="headerlink" title="背景与设计原则"></a>背景与设计原则</h1><p>近年来，在性能、安全性和可观测性目标方面，对Linux内核进行定制已成为不同行业普遍的需求。过去二十年间，Linux内核定制已从一个边缘化的考虑因素演变为满足各种运营需求的关键所在。</p><h2 id="内核定制所面临的挑战"><a href="#内核定制所面临的挑战" class="headerlink" title="内核定制所面临的挑战"></a>内核定制所面临的挑战</h2><p>开发人员在需要直接对Linux内核进行修改时，常常会遇到重大障碍。一下是一些主要的挑战。</p><p>Linux在编译期间和运行时都提供了大量的配置选项。然而，这些选项并不能从根本上解决性能瓶颈问题，也无法提供有关内核行为的深入见解。它们适用于调整现有内核策略的参数，但不足以表达新的策略。</p><p>在这种情况下，如果需要定制内核，开发人员就需要对内核代码进行修改，和/或编写内核模块。然而，这会使测试和调试变更变得困难很多。对内核进行复杂更改需要对复杂的代码库有深入的了解，从而带来巨大的维护负担。除非这些更改得到内核社区的认可，否则在内核升级时需要将其向前移植，因为内核API不稳定。代码中任何未发现的错误都可能导致系统崩溃并产生服务其瘫痪，这直接导致停机和收入损失。</p><p>部署内核变更，即使是最小的内核变更，要在服务器集群中部署也是一项耗时的过程。用新内核替换正在运行的内核会导致机器上承载的工作负载中断，因为这些工作负载必须停止。然后，机器需要重新启动进入新内核，并重新初始化所有服务。这于那些冷启动时间长且启动耗时显著的工作负载来说，这个循环尤其有害。完成所有这些步骤之后，还需要进行广泛的测试阶段来测试和验证这些变更，并修复任何检查到的退化问题。对于每台接收内核更新的服务器，都必须重复这个过程，这使得整个过程成本高昂，将新内核部署到整个集群所需的时间通常以周或月来计算。</p><h2 id="替代方法及局限性"><a href="#替代方法及局限性" class="headerlink" title="替代方法及局限性"></a>替代方法及局限性</h2><p>正如第2.1节所述，开发人员在对内核进行更改时会面临复杂性。我们在此讨论了一些替代方法，这些方法有望带来性能提升，但也存在局限性和维护方面的挑战。</p><p><strong>完全绕过内核或替换内核（Completeley Bypassing or Replacing the Kernel）</strong>。尽管针对特定工作负载的内核绕过框架和库操作系统在性能方面颇具吸引力，但它们也存在自身的缺点。内核绕过解决方案需要完全控制硬件，并且在忙于轮询时会浪费CPU周期。库操作系统是为特定工作负载量身定制的，需要对代码进行修改才能适应不同的需求。此外，这两种方法都使得两个工作负载难以共存或共享硬件资源，这对某些用户来说是不可接受的。最后，它们需要重写应用程序逻辑，这是一项重大的维护负担。</p><p>eBPF通过运行在运行时安全且动态地高效定制Linux内核，从而满足了这些要求，降低了对内核进行更改时引入内核错误的风险，并加快了开发和部署的速度。在eBPF推出之前，内核在网络子系统中有多个针对特定领域的基于寄存器的虚拟机来服务特定用例，但它们都不是通用的。</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>我们现在概述一下eBPF持续发展和演进背后的关键设计原则。</p><p>在内核中托管安全高效的虚拟机允许时环境，能够实现内核的<strong>动态定制（Safe and Dynamic OS Customization）</strong>，其性能可与现有的内核代码相媲美，同时确保内核的完整性在任何情况下都不会收到损害。针对具有受限环境的安全虚拟机进行编程，能够降低对内核进行修改的门槛。这种安全性保障使得将此类程序部署到内核时更具信心，与直接修改内核或内核模块相比，降低了引入可能导致服务中断的内核错误的风险。</p><p><strong>快速部署与升级（Rapid Deployment and Upgrades）</strong> 更改内核并在大量服务器上进行部署的成本相当高昂，因为重启一台机器会带来终止并重新初始化服务的开销。在运行时动态将程序加载到内核中，能够实现快速部署，且不会造成任何服务中断。同时，通过在运行时卸载和重新加载程序，修复错误和根据收集到的遥测数据进行迭代改进的速度也会大幅提高。这极大地简化了部署流程，加快了测试和验证内核更改的反馈循环，并加速了开发进程。</p><p><strong>与内核集成（Integration with the Kernel）</strong> 虽然程序会连接到内核以引入代替行为，但它们应当能够安全地与现有的内核状态进行交互，并在需要时对其进行操作。同时，如果程序没有需要执行的操作，它们应当能够回退到现有的内核处理过程。这为用户提供了灵活的模型，在需要时可以利用现有的内核实现，而无需在程序中重新实现类似的代码。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>eBPF被定义为一种支持eBPF指令集的抽象虚拟机。该虚拟机具有11个寄存器和一个固定大小的栈。eBPF程序在Linux内核提供的受限虚拟机环境中运行。eBPF指令集是一组小巧但功能多样的64位指令。这些指令提供了广泛的功能，使eBPF程序能够在内核空间中高效地执行各种任务。该指令集支持加法、减法、乘法和位操作（例如，与、或、异或）等 算术运算。此外它还支持加载和存储指令以及包括条件和无条件跳转在内的跳转指令，以改变程序流程，以及函数调用和退出。该指令集还具有原子操作，旨在实现安全的内存访问和修改。这些原子操作确保并发访问不会导致不一致或损坏。</p><h2 id="The-eBPF-Runtime"><a href="#The-eBPF-Runtime" class="headerlink" title="The eBPF Runtime"></a>The eBPF Runtime</h2><p>eBPF运行时是一组必要组件，用于将抽象虚拟机及相关实体映射到另一个操作系统或硬件平台上。对于Linux内核而言，内核中的eBPF子系统实现了eBPF运行时，并定义了与之交互的系统调用接口。下面，我们将展示构成eBPF生态系统的关键组件，如图1所示。<br><img src="/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/eb9b4a3c-3300-475b-ab66-2ea70d718fd0.png" alt="image.png"></p><p><strong>eBPF字节码（eBPF Bytecode）</strong> eBPF字节码被定义为有限的eBPF指令序列。eBPF虚拟机执行使用eBPF字节码编码的eBPF程序。每个程序由一个或多个子程序（简称subprogs）组成。这些字程序只是类似于函数的字包含字节码单元。程序的执行从主子程序（main）开始。</p><p><strong>eBPF用户空间加载器（eBPF Userspace Loader）</strong> eBPF拥有活跃的用户空间加载器生态系统，例如BBC、Bptrace和libbpf，这些加载器通过BPF_PROG_LOAD系统调用将eBPF字节码加载到内核，并将程序附加到相关钩子（hooks），同时管理任何响应的映射。会返回一个文件描述符，它代表已加载的程序，然后可以将其用于将程序附加到特定的内核钩子。在本文中，我们将讨论和阐述的重点放在LLVM工具链，将C前端和libbpf上，它们共同构成了最受欢迎且功能最丰富的参考实现。</p><p><strong>eBPF验证器（eBPF Verifier）</strong> 验证器是eBPF系统中的关键组件，它会在字节码被内核接受之前对其进行检查，确保与eBPF相关的安全属性，并且在任何情况下加载程序都不会对内核的完整性和安全性产生负面 影响。</p><p><strong>eBPF即时编译器和解释器（eBPF Just-In-Time Compiler and Interpreter）</strong> 在验证过程完成后，程序会使用即时（JIT）编译器编译为本地机器指令。然后内核为加载的程序分配一个文件描述符，简化其与内核中各种执行钩子的连接。在即时编译（JIT）被禁用或不支持的情况下，eBPF解释器承担起程序执行的责任，实时动态地解释和执行字节码。</p><p><strong>eBPF挂钩（eBPF Hooks）</strong> eBPF程序的流程由事件决定，当内核或应用程序遇到特定的挂钩时，这些事件就会被执行。这些预定义的挂钩点位于内核的多个位置，涵盖了系统调用，函数入口和出口、网络套接字、跟踪点等多种事件。根据其挂载类型和/或程序类型，程序会被挂载到其应运行的挂钩上。如果预定义的挂钩不符合要求，开发人员可以创建自定义挂钩点，称为内核探测（Kprobes）或用户探测（uprobes）。这些探测使得eBPF程序能够几乎挂载到内核或用户应用程序内的任何位置。</p><p><strong>eBPF程序类型（eBPF Program Types）</strong> <code>BPF_PROG_TYPE</code>是对eBPF程序的分类，它决定了程序的功能、输入参数、可执行操作以及在内核中的挂载点。每种程序类型都有其特定的特性，这些特性定义了其行为以及与系统的交互方式。例如，套接字过滤器程序类型<code>BPF_PROG_TYPE_SOCKET_FILTER</code>旨在检查和管理套接字级别的网络数据包。开发人员可以在这些程序中设计自定义逻辑，以根据需要分析和修改传入和传出的数据包。相反，跟踪程序类型<code>BPF_PROG_TYPE_TRACING</code>能够监控内核事件，并提供有关系统运行的有价值信息。这些程序类型及其挂载类型在内核代码库中定义，是创建不同需求的eBPF程序的蓝图。</p><p><img src="/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/97168117-cf8a-4348-8f5c-d6f5f72c6587.png" alt="image.png"></p><p><strong>eBPF辅助函数（eBPF Helpers）</strong> eBPF辅助函数是eBPF程序可访问的专用函数，能够实现与系统及其上下文的交互。这些辅助函数有助于完成诸如打印调试消息、获取系统启动时间、处理网络数据包以及与eBPF映射进行交互等任务。每种eBPF程序类型都可以访问特定的辅助函数子集，这些子集根据其上下文和需求进行了定制。有关bpf辅助函数的详细信息，请参阅内核提供的文档[1]。</p><p><strong>eBPF映射（eBPF Maps）</strong> eBPF映射是一种特定类型的抽象数据结构，例如数组或哈希映射，它有助于用户空间和内核之间的数据交换。在eBPF虚拟机中运行的程序可以通过特定于平台的加载指令访问一个或多个映射。</p><h2 id="eBPF对象及其生命周期"><a href="#eBPF对象及其生命周期" class="headerlink" title="eBPF对象及其生命周期"></a>eBPF对象及其生命周期</h2><p>每个eBPF对象在内核中都有一个表现形式，用于管理内核中的eBPF程序，并通过文件描述符向用户空间公开。eBPF对象的生命周期与文件描述符的生命周期相关联。一旦与eBPF对象对应的最后一个文件符被释放，其在内核中的状态也会被释放。为了实现超出进程生命周期的持久性，内核允许将这些文件描述符固定在名为<code>bpffs</code>的特殊伪文件系统上。每次固定操作都会对eBPF对象进行引用，从而延长生命周期。</p><p><strong>eBPF程序</strong> 这些对象代表实际加载到内核中的程序。在eBPF验证器验证并即时编译（JIT）程序并创建其内核表示形式后，bpf系统调用的<code>BPF_PROG_LOAD</code>命令会返回一个表示该程序的文件描述符。加载完毕后，该程序即可准备附加到指定的内核钩子上。</p><p><strong>eBPF映射</strong> 当创建eBPF程序时，会使用bpf系统调用中的<code>BPF_MAP_CREATE</code>命令来定义映射，该命令会返回一个文件描述符。此描述符在eBPF程序中的伪加载指令用于引用映射。在程序验证期间，验证器会将文件描述符解析为内核中的实际映射对象，并将伪加载指令的目的寄存器视为程序中的eBPF映射指针。</p><p><strong>eBPF链接</strong> eBPF链接在确保eBPF探针的生命周期长于触发它们的应用程序的生命周期方面发挥着关键作用。eBPF链接是通过bpf系统调用的<code>BPF_LINK_CREATE</code>命令创建的。该链接使开发人员能够间接的将eBPF程序附加到内核挂钩上，提供了一种比常规直接附加方法更灵活、更持续的方式。与直接附加到挂钩不同，创建eBPF链接将程序附加的生命周期与文件描述符绑定在一起，从而简化了程序引用的管理，并且即使加载它的应用程序意外终止，也能保持探针的允许。与eBPF链接相关的文件描述符控制着它的生命周期。当最后一个文件描述符被关闭时，链接会将其程序从内核钩子中分离出来，从而能够清理资源。只有链接所有者才能分离或更新它，这确保了系统的完整性，并防止了未经授权的修改。</p><p><strong>BTF</strong> BTF对象代表从用户空间提交到内核的eBPF程序或映像的BTF类型信息，以便验证器在验证过程中将此类信息与程序或映射关联起来。对于内核及其模块，这些对象会在启动时以及加载任何内核模块时自动创建。我们在第3.4节详细阐述了两BTF如何在其他多个用例中发挥了重要作用。</p><h2 id="eBPF指令集"><a href="#eBPF指令集" class="headerlink" title="eBPF指令集"></a>eBPF指令集</h2><p>eBPF指令集是根据eBPF虚拟机来定义的。它支持两种指令编码（64位和128位），通用指令（如算术运算、跳转、调用、加载和存储）以及对11个64位寄存器（r0-r10）的寻址，这些寄存器遵循明确的调用约定，其中r10为只读寄存器，指向栈顶。有关指令集和调用约定的完整正式描述，请参阅eBPF指令集规范。</p><p>在整个指令集的设计过程中，所遵循的一个关键原则是保持与实际硬件指令集架构（ISA）的高度等效性，这简化了解释器和即时编译器（JIT）的实现。此外，这种高度等效性使得优化编译器后端能够生成性能接近原生编译程序的eBPF汇编代码。这是因为JIT可以将eBPF指令几乎一对一地映射为本地机器指令，而无需引入任何额外的处理机制来处理这种转换。</p><p>将指令集与Linux内核中的eBPF运行时解耦的优势之一在于能够在操作系统之外使用它。eBPF指令集架构（ISA）要么可由硬件直接支持，要么可转换为目标硬件架构。这对计算硬件也具有巨大潜力，因此eBPF运行时可以控制并决定是否进行卸载，因为eBPF运行时可以控制并决定是否进行卸载，而针对特定钩子编写的程序可以采用无感知的方式。Kicinski等人已经展示了将XDP钩子的eBPF程序卸载到可编程网络接口卡（NIC）上，而Lukken等人则探讨了其在计算存储设备中的应用。</p><h2 id="BPF类型格式"><a href="#BPF类型格式" class="headerlink" title="BPF类型格式"></a>BPF类型格式</h2><p>BPF类型格式（简称BTF）是一种专门用于eBPF的调试信息格式。它由编译器在编译内核或eBPF程序时生成。除了C类型的信息外，它还包含函数原型信息、类型和声明的自定义注释（这些注释对eBPF验证器具有上下文相关的意义）以及源代码信息，以便更好地进行内省和调试。有关元数据格式的正式描述，请参阅BTF文档。</p><p>新的调试信息格式的好处有两方面。首先，内核使用的现有调试信息格式——任意记录格式调试（DWARF），如果嵌入内核映像中，会带来较大的内存消耗开销。这意味着始终在内核中附带调试信息（eBPF验证器可以利用这些信息来丰富其静态分析）是不可行的。其次，为了更好地对eBPF程序和映射进行内省和分析，它们需要提供自己的调试信息，以便验证器进行检查。这意味着要在内核中引入复杂的代码来解析DWARF调试信息，这在维护和安全方面都是不可取的。</p><p>BTF解决了所有这些问题。由于其紧凑的表示形式，对于编译器生成的相同内核映像，BTF调试信息的内存消耗比DWARF调试信息少一个数量级。这主要归功于Nakryiko等人设计的激进的去重算法，该算法旨在减少BTF的内存占用。</p><p>反过来，这使得BTF总是能与内核和eBPF程序一起打包，而验证器在执行静态分析时会大量以来这些信息。由于其表示形式更简单，BTF的处理速度也更快，这一点至关重要，因为在运行时会为内核，任何已加载的内核模块以及所有提供BTF信息的eBPF程序和映射创建内核中的表示形式。</p><p>我们现在通过BTF的主要用例来说明其优势。</p><p><strong>验证（Verification）</strong> BTF的主要使用者是eBPF验证器。它利用内核的BTF信息来确保eBPF程序对所获取内核指针的类型安全。验证器会通过BTF检查类型信息以确定其可以访问和内省结构体类型的成员。</p><p><strong>注释（Annotations）</strong> BTF可以为内核或程序中使用的函数和变量的类型及声明携带自定义注释。这些注释用于为类型附加上下文相关的含义，以辅助验证。</p><p><strong>调试（Debugging）</strong> 在eBPF程序和映射中使用BTF可以实现更好的内省和可调式性。在分析程序时，验证器可以将其源代码和行信息打印到日志中，这在程序因用户输出被拒绝时非常有用。它还允许使用源信息对eBPF字节码和JIT编译代码进行注释。这于eBPF映射，通过识别其BTF中的数据类型，可以使其数据转储具有结构性。</p><p><strong>编译一次，随处运行（CO-RE，Compile Once Run Everywhere）</strong> CO-RE是eBPF程序的一组重定位的统称。这些重定位通过该结构体成员的内存访问、命名枚举常量值和命名内核配置选项的符号引用进行编码，使编译后的程序更具可移植性。所有这些重定位在加载程序时均由验证器或libbpf解决。这种动态解析确保来eBPF程序能够适应不同的内核版本和架构，而无需重新编译。</p><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><p>在本节中，我们将说明eBPF的高级编程和执行模型。图3展示了从头到尾和执行我们所选实例的eBPF程序所设计的整个流程。</p><p><img src="/2025/11/02/The-eBPF-Runtime-in-the-Linux-Kernel/9e2a8dbc-f831-4538-b1bd-66e3252c4cad.png" alt="image.png"></p><p>用户通常从步骤<em><strong>s1</strong></em>开始，使用高级编程语言编写一个eBPF程序。在我们的示例只能够，考虑的是为XDP钩子编写的C程序（见Listing 1)，该程序在网络设备驱动程序层处理网络数据包之前被调用。类型为<code>struct xdp_md</code>的<code>ctx</code>参数代表程序可访问的原始网络数据包。<code>data</code>和<code>data_end</code>指针变量分别指向网络数据包数据区域的起始位置和结束位置。通过比较<code>data</code>和<code>data_end</code>的条件分支来确保有足够的空间，以保证对数据包数据的内存访问是安全的。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 1: an example BPF program for the XDP hook,</span></span><br><span class="line"><span class="comment">// which drops all incoming IPv4 UDP traffic</span></span><br><span class="line"></span><br><span class="line">SEC(*xdp*)</span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_program</span><span class="params">(<span class="keyword">struct</span> xdp_md *ctx)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">void</span> *data_end = (<span class="type">void</span> *)(<span class="type">long</span>)ctx-&gt;data_end;</span><br><span class="line">    <span class="type">void</span> *data = (<span class="type">void</span> *)(<span class="type">long</span>)ctx-&gt;data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> =</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eth + <span class="number">1</span> &lt; data_end){</span><br><span class="line">        <span class="keyword">if</span> (eth-&gt;h_proto == bpf_htons(ETH_P_IP))</span><br><span class="line">        {</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> =</span> (<span class="type">void</span> *)(eth + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (iph + <span class="number">1</span> &lt; data_end &amp;&amp; iph-&gt;protocol ==IPPROTO_DUP)</span><br><span class="line">                <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> XDP_PASS</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//data 报文在DMA缓冲区中的起始地址</span></span><br><span class="line"><span class="comment">//data_end 报文在DMA缓冲区中的结束地址</span></span><br><span class="line"><span class="comment">//long 是为了消除verifier对32位截断的警告</span></span><br><span class="line"><span class="comment">//在C里 eth+1 指针步进一个 sizeof(struct ethhdr)的大小，即14字节</span></span><br></pre></td></tr></tbody></table></figure><p>下一步<em><strong>S2</strong></em>涉及将此C语言代码进行编译。使用LLVM工具链中的clang编译器将程序编译为对象文件。编译的目标选择为bpf，这指示编译器使用eBPF后端为生成的对象文件生成二进制代码。</p><p>步骤<em><strong>S3</strong></em>关注的是对生成的目标文件进行处理，并通过<code>bpf(2)</code>系统调用将其中编程的程序提交给内核以进行加载。在我们的示例中，我们使用bpftool用户空间工具，该工具又借助libbpf库来执行程序的加载操作。一旦目标文件处理完毕且程序已从其中提取出的信息在步骤<em><strong>S4</strong></em>中提交内核。通过使用<code>bpf(2)</code>系统调用的<code>BPF_PROG_LOAD</code>命令调用eBPF验证器。</p><p>eBPF验证器随后会对程序进行验证，以确定其在内核中执行是否安全。如果验证器无法确定程序的安全性，则会拒绝该程序并向用户空间返回错误。否则，验证成功的程序会被即时编译，并将与eBPF程序对应的文件描述符返回给用户空间。</p><p>一旦用户空间获取来该文件的描述符，它现在就可以链接到网络设备的XDP钩子上。例如，网络设备名为eth0，步骤<em><strong>S5</strong></em>涉及调用<code>bpf(2)</code>系统调用的<code>BPF_LINK_CREATE</code>命令，将程序附加到网络设备。如果该命令的参数均有效，则内核会将与eBPF链接对应的文件描述符返回给用户空间。</p><p>此时，eBPF程序已经加载到eth0网络接口，并拒绝所有针对该接口传入的IPv4 UDP流量。它会在内核网络设备驱动程序接收到的每一个原始网络数据包时被调用，并对其进行处理。其余流量则会传递到内核的网络栈。</p><p>在步骤<em><strong>S6</strong></em>中，一旦用户空间应用程序关闭了eBPF链接的文件描述符，程序与网络接口将分离。一旦eBPF程序文件在步骤<em><strong>S7</strong></em>中被关闭文件描述符后，内核将会释放它所占用的资源，例如其代码所需的内存。</p><h1 id="eBPF程序的安全性"><a href="#eBPF程序的安全性" class="headerlink" title="eBPF程序的安全性"></a>eBPF程序的安全性</h1><p>程序安全性是eBPF程序的一个关键方面，它确保程序能够正确且安全地执行，同时不会损害Linux内核的稳定性和安全性。在eBPF程序的语境中，程序安全性指的是为保护内核运行时的完整性以及维护eBPF程序执行所在的内核上下文的不变形而必须满足的一系列属性。违反这些安全属性的程序在加载到内核时应被拒绝。</p><p>[1]:bpf-helpers(7) — Linux manual page. <a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">https://man7.org/linux/man-pages/man7/bpf-helpers.7.html</a>. Accessed:2024-06-09.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Linux内核中的eBPF运行时环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;翻译文献The eBPF Runtime in the Linux Kernel&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;</summary>
      
    
    
    
    
    <category term="eBPF" scheme="http://jiuzhao14.github.io/tags/eBPF/"/>
    
  </entry>
  
</feed>
